package pkg.trader;

import java.util.ArrayList;

import pkg.exception.StockMarketExpection;
import pkg.market.Market;
import pkg.order.BuyOrder;
import pkg.order.Order;
import pkg.order.OrderType;
import pkg.order.SellOrder;

public class Trader {
	// Name of the trader
	private String name;
	// Cash left in the trader's hand
	double cashInHand;
	// Stocks owned by the trader
	ArrayList<Order> position;
	// Orders placed by the trader
	ArrayList<Order> ordersPlaced;

	public Trader(String name, double cashInHand) {
		super();
		this.setName(name);
		this.cashInHand = cashInHand;
		this.position = new ArrayList<Order>();
		this.ordersPlaced = new ArrayList<Order>();
	}
	

	public void buyFromBank(Market m, String symbol, int volume)
			throws StockMarketExpection {
		// Buy stock straight from the bank
		// Need not place the stock in the order list
		double purchasePrice;
		double stockPrice = m.getStockPrice(symbol);
		purchasePrice = (volume * stockPrice);
		
		if(cashInHand < purchasePrice){
		throw new StockMarketExpection("Insufficent funds!!!");	
		}
		else{
		 cashInHand = (cashInHand - purchasePrice);
		 BuyOrder bankBuy = new BuyOrder(symbol, volume, stockPrice, this);
		 position.add(bankBuy);
		}
		// Add it straight to the user's position
		// If the stock's price is larger than the cash possessed, then an
		// exception is thrown
		// Adjust cash possessed since the trader spent money to purchase a
		// stock.
	}

	public void placeNewOrder(Market m, String symbol, int volume,
			double price, OrderType orderType) throws StockMarketExpection {
		// Place a new order and add to the orderlist
		// Also enter the order into the orderbook of the market.
		// Note that no trade has been made yet. The order is in suspension
		// until a trade is triggered.
		//double purchasePrice;
		//double stockPrice = m.getStockPrice(symbol);
		//purchasePrice = (volume * stockPrice);
		// If the stock's price is larger than the cash possessed, then an
		// exception is thrown
		//if(cashInHand < purchasePrice){
		//throw new StockMarketExpection("Insufficent funds!!!");	
		//}
		//else{
		 //cashInHand = (cashInHand - purchasePrice);
		 if (orderType == OrderType.BUY) {
			 BuyOrder newBuy = new BuyOrder(symbol, volume, price, this);
			 ordersPlaced.add(newBuy);
			 m.addOrder(newBuy);
		 }
		 else {
			 SellOrder newSell = new SellOrder(symbol, volume, price, this);
			 ordersPlaced.add(newSell);
			 m.addOrder(newSell);
		 }
		 
		//}
		
		
		// A trader cannot place two orders for the same stock, throw an
		// exception if there are multiple orders for the same stock.
		// Also a person cannot place a sell order for a stock that he does not
		// own. Or he cannot sell more stocks than he possesses. Throw an
		// exception in these cases.

	}

	public void placeNewMarketOrder(Market m, String symbol, int volume,
			double price, OrderType orderType) throws StockMarketExpection {
		// Similar to the other method, except the order is a market order
		//double purchasePrice;
		//double stockPrice = m.getStockPrice(symbol);
		//purchasePrice = (volume * stockPrice);
		// If the stock's price is larger than the cash possessed, then an
		// exception is thrown
		//if(cashInHand < purchasePrice){
		//throw new StockMarketExpection("Insufficent funds!!!");	
		//}
		if (orderType == OrderType.BUY) {
			 BuyOrder newBuy = new BuyOrder(symbol, volume, price, this);
			 ordersPlaced.add(newBuy);
			 m.addOrder(newBuy);
		 }
		 else {
			 SellOrder newSell = new SellOrder(symbol, volume, price, this);
			 ordersPlaced.add(newSell);
			 m.addOrder(newSell);
		 }
	}

	public void tradePerformed(Order o, double matchPrice)
			throws StockMarketExpection {
		
		String orderType = o.getType();
		int size = o.getSize();
		String symbol = o.getStockSymbol(); 
		
		if(orderType == "Buy"){
			double purchasePrice = (size * matchPrice);
			if(cashInHand < purchasePrice){throw new StockMarketExpection("Insufficent funds!!!");}
			else{
				cashInHand = (cashInHand - purchasePrice);	
				BuyOrder buyStock = new BuyOrder(symbol, size, matchPrice, this);
				position.add(buyStock);
				}
			}
		else if(orderType == "Sell"){
			double profit = (size * matchPrice);
			cashInHand = (cashInHand + profit);
			Order sellOrder;
			sellOrder = position.get(0);
			int currentPosSize = sellOrder.getSize();
			if(currentPosSize < size){throw new StockMarketExpection("Insufficent stock size!!!");}
			int newPositionSize = (currentPosSize - size);
			
			SellOrder sellStock = new SellOrder(symbol, newPositionSize, matchPrice, this);
			ArrayList<Order> newPosition = new ArrayList<Order>();
			//Create new position
			newPosition.add(sellStock);
			//Set trader new position after reducing size
			setPosition(newPosition);
		}
		// Notification received that a trade has been made, the parameters are
		// the order corresponding to the trade, and the match price calculated
		// in the order book. Note than an order can sell some of the stocks he
		// bought, etc. Or add more stocks of a kind to his position. Handle
		// these situations.
		

		// Update the trader's orderPlaced, position, and cashInHand members
		// based on the notification.
	}

	public ArrayList<Order> getPosition() {
		return position;
	}


	public void setPosition(ArrayList<Order> position) {
		this.position = position;
	}


	public void printTrader() {
		System.out.println("Trader Name: " + getName());
		System.out.println("=====================");
		System.out.println("Cash: " + cashInHand);
		System.out.println("Stocks Owned: ");
		for (Order o : position) {
			o.printStockNameInOrder();
		}
		System.out.println("Stocks Desired: ");
		for (Order o : ordersPlaced) {
			o.printOrder();
		}
		System.out.println("+++++++++++++++++++++");
		System.out.println("+++++++++++++++++++++");
	}


	public ArrayList<Order> getOrdersPlaced() {
		// TODO Auto-generated method stub
		return ordersPlaced;
	}
	
	public void setOrdersPlaced(ArrayList<Order> ordersPlaced) {
		// TODO Auto-generated method stub
		this.ordersPlaced = ordersPlaced;
	}


	public String getName() {
		return name;
	}


	public void setName(String name) {
		this.name = name;
	}
}
